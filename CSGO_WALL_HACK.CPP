#include <iostream>
#include <iomanip>
#include <vector>
#include <Windows.h>
#include <TlHelp32.h>

using namespace std;

// MEMORY READ WRiTE GETPiD CLASS BlueMethMEMORY Module
class BlueMethMem
{
public:
	 BlueMethMem();
	~BlueMethMem();

	template <class val>
	val readMem(uintptr_t addr)
	{
		val x;
		ReadProcessMemory(handle, (LPBYTE*)addr, &x, sizeof(x), NULL);
		return x;
	}

	template <class val>
	val writeMem(uintptr_t addr, val x)
	{
		WriteProcessMemory(handle, (LPBYTE*)addr, &x, sizeof(x), NULL);
		return x;
	}
	uintptr_t getProcess(const wchar_t*);
	uintptr_t getModule(uintptr_t, const wchar_t*);
	uintptr_t getAddress(uintptr_t, std::vector<uintptr_t>);

private:
	HANDLE handle;
};
BlueMethMem::BlueMethMem() { handle = NULL; }
BlueMethMem::~BlueMethMem()
{
	CloseHandle(handle);
}

// RETURN THE PiD VALUE
uintptr_t BlueMethMem::getProcess(const wchar_t* proc)
{
	HANDLE hProcessId = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
	uintptr_t process;
	PROCESSENTRY32 pEntry;
	pEntry.dwSize = sizeof(pEntry);
	do
	{
		if (!_wcsicmp(pEntry.szExeFile, proc))
		{
			process = pEntry.th32ProcessID;
			CloseHandle(hProcessId);
			handle = OpenProcess(PROCESS_ALL_ACCESS, false, process);
		}
	} while (Process32Next(hProcessId, &pEntry));
	return process;
}

// GET THE CLiENT.DLL MODULE ADDRESS FROM THE EXECUTABLE
uintptr_t BlueMethMem::getModule(uintptr_t procId, const wchar_t* modName)
{
	HANDLE hModule = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE | TH32CS_SNAPMODULE32, procId);
	MODULEENTRY32 mEntry;
	mEntry.dwSize = sizeof(mEntry);
	do
	{
		if (!_wcsicmp(mEntry.szModule, modName))
		{
			CloseHandle(hModule);
			return (uintptr_t)mEntry.hModule;
		}
	} while (Module32Next(hModule, &mEntry));
	return 0;
}
uintptr_t BlueMethMem::getAddress(uintptr_t addr, std::vector<uintptr_t> vect)
{
	for (int i = 0; i < vect.size(); i++)
	{
		ReadProcessMemory(handle, (BYTE*)addr, &addr, sizeof(addr), 0);
		addr += vect[i];
	}
	return addr;
}
BlueMethMem MemClass;

//DEFINE ALL THE OFFSET VAL iN THiS STRUCTURE
struct offset
{
	DWORD m_iTeamNum = 0xF4;
	DWORD m_iGlowIndex = 0xA40C;
	DWORD dwEntityList = 0x4D06CB4;
	DWORD dwLocalPlayer = 0xCF4A3C;
	DWORD dwGlowObjectManager = 0x52470F0;
}offset;

//VAR STRUCT FOR LOCAL PLAYER AND GAMEMODULE
struct variables
{
	DWORD localPlayer;
	DWORD gameModule;
}val;

//MAiN EXEC FUNCTION TO HOOK THE CHANGES IN THE PROCESS ADDRESS
int main()
{
	int LL=0; string UserMain = "HEiSENBERG", UserPass = "spacex", USER1, PASS1;
	cout << "[-------------------   [HEiSENBERG.IO]   ------------------]\n";
	cout<< "[------ ENTER YOUR LOGiN CREDENTiALS [HEiSENBERG.ME] ------]\n";
	cout << "ENTER YOUR UID: >>> "; cin>>USER1;
	cout << "ENTER YOUR PASS: >>> "; cin>>PASS1;

	if (UserMain != USER1 || UserPass != PASS1)
	{
		cout << "\nBAD-AUTH >>> [IP-WiLL-BE-REPORTED-TO-ViSWANATHAN]\n";
		for (int i = 0; i < 5; i++)
		{
			Beep(2225, 500);
		}
		Sleep(2500);
		exit(0);
	}
	else
	{
		cout << "\nAUTH-SUCCESS >>> [DOWNLOADING-BLUE-METH-FROM-SJT]\n"; Beep(250, 1000);
		cout << "WAiT >>> ";
		while (LL < 8)
		{
			cout << " [=] ";
			Sleep(500);
			LL++;
		}
	}

	MessageBoxA(0, "HEiSENBERG WiLL INJECT BLUE METH IN YOUR RAM","HEiSENBERG.ME",0);
	MessageBoxA(0, "[SUCCESS] - FEEL THE GAMESENSE", "HEiSENBERG.ME", 0);
	MessageBoxA(0, "[1] DiSCORD - HEiSENBERG#0487\n[2] STEAM - https://steamcommunity.com/id/-heisen-official/", "CONTACT", 0);

	printf("\n\n[USAGE]\n[1]-ViSHNU-THiRD-EYE-ESP  [INSERT-KEY]\n[2]-EXiT-UNHOOK [END-KEY]\n");

	int ProcessID = MemClass.getProcess(L"csgo.exe");
	val.gameModule = MemClass.getModule(ProcessID, L"client_panorama.dll");
	val.localPlayer = MemClass.readMem<DWORD>(val.gameModule + offset.dwLocalPlayer);

	if (val.localPlayer == NULL)
		while (val.localPlayer == NULL)

			val.localPlayer = MemClass.readMem<DWORD>(val.gameModule + offset.dwLocalPlayer);

	bool TOG = false;

	while (true)
	{	
		DWORD glowObject = MemClass.readMem<DWORD>(val.gameModule + offset.dwGlowObjectManager);
		int myTeam = MemClass.readMem<int>(val.localPlayer + offset.m_iTeamNum);
		for (short int i = 0; i < 60; i++)
		{

			DWORD entity = MemClass.readMem<DWORD>(val.gameModule + offset.dwEntityList + i * 0x10);
		
			if (TOG && entity != NULL )
			{
				int glowIndx = MemClass.readMem<int>(entity + offset.m_iGlowIndex);
				int entityTeam = MemClass.readMem<int>(entity + offset.m_iTeamNum);

				if (myTeam == entityTeam)
				{
					MemClass.writeMem<float>(glowObject + ((glowIndx * 0x38) + 0x4), 0);
					MemClass.writeMem<float>(glowObject + ((glowIndx * 0x38) + 0x8), 0);
					MemClass.writeMem<float>(glowObject + ((glowIndx * 0x38) + 0xC), 2);
					MemClass.writeMem<float>(glowObject + ((glowIndx * 0x38) + 0x10), 1);
				}
				else
				{
					MemClass.writeMem<float>(glowObject + ((glowIndx * 0x38) + 0x4), 2);
					MemClass.writeMem<float>(glowObject + ((glowIndx * 0x38) + 0x8), 0);
					MemClass.writeMem<float>(glowObject + ((glowIndx * 0x38) + 0xC), 0);
					MemClass.writeMem<float>(glowObject + ((glowIndx * 0x38) + 0x10), 1);
				}
				MemClass.writeMem<bool>(glowObject + ((glowIndx * 0x38) + 0x24), true);
				MemClass.writeMem<bool>(glowObject + ((glowIndx * 0x38) + 0x25), false);
				
			}
			if (GetAsyncKeyState(VK_INSERT))
			{
				if (TOG == false)
				{
					Sleep(250);
					TOG = true;
				} 
				else if (TOG == true)
				{
					Sleep(250);
					TOG = false; 
				}
			}
			if (GetAsyncKeyState(VK_END))
			{
				exit(0);
			}
		}
		Sleep(1);
	}
	return 0;
}
